<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> RAMP: Real-Time Aggregated Matrix Profile | </title> <meta name="description" content=" post 13 "> <meta name="keywords" content="RAMP, real-time, Real, Time, real, time, matrix, profile, anomaly, anomalies, machine, learning, ramp, research, paper, scientific, research, credibility, workflows, big, data"> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <!-- Social: Facebook / Open Graph --> <meta property="og:type" content="article"> <meta property="article:author" content="Jerome Dinal Herath"> <meta property="article:section" content=""> <meta property="article:tag" content="RAMP, real-time, Real, Time, real, time, matrix, profile, anomaly, anomalies, machine, learning, ramp, research, paper, scientific, research, credibility, workflows, big, data"> <meta property="article:published_time" content="2020-04-09 00:00:00 -0400"> <meta property="og:url" content="http://dinalherath.com/2020/ramp/"> <meta property="og:title" content=" RAMP: Real-Time Aggregated Matrix Profile | "> <meta property="og:image" content="http://dinalherath.com"> <meta property="og:description" content=" post 13 "> <meta property="og:site_name" content="Jerome Dinal Herath"> <meta property="og:locale" content="en_US"> <!-- Social: Twitter --> <meta name="twitter:card" content=""> <meta name="twitter:site" content=""> <meta name="twitter:title" content=" RAMP: Real-Time Aggregated Matrix Profile | "> <meta name="twitter:description" content=" post 13 "> <meta name="twitter:image:src" content="http://dinalherath.com"> <!-- Social: Google+ / Schema.org --> <meta itemprop="name" content=" RAMP: Real-Time Aggregated Matrix Profile | "> <meta itemprop="description" content=" post 13 "> <meta itemprop="image" content="http://dinalherath.com"> <!-- rel prev and next --> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/font-awesome.min.css"> <!-- Canonical link tag --> <link rel="canonical" href="http://dinalherath.com/2020/ramp/"> <link rel="alternate" type="application/rss+xml" title="" href="http://dinalherath.com/feed.xml"> <script type="text/javascript"> var disqus_shortname = ''; var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-99988883-1']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); </script> </head> <body> <main class="wrapper"> <header class="site-header"> <nav class="nav"> <div class="container"> <h1 class="logo"><a href="/"><span></span></a></h1> <ul class="navbar"> <li><a href="/">About</a></li> <li><a href="/blog">Blog</a></li> <li><a href="/research">Research</a></li> <li><a href="/dinal_cv.pdf">CV</a></li> <!-- <li><a href="/resume">Resume</a></li>--> <!--<li><a href="/contact">Contact</a></li>--> </ul> </div> </nav> </header> <article class="post container" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"> </script> <p class="post-meta"><time datetime="2020-04-09T00:00:00-04:00" itemprop="datePublished">Apr 9, 2020</time></p> <h1 class="post-title" itemprop="name headline">RAMP: Real-Time Aggregated Matrix Profile</h1> </header> <div class="post-content" itemprop="articleBody"> <p><img src="http://dinalherath.com/material/2020/post_13/ramp_model.jpeg" alt="ramp-image" width="540px" /> <br /></p> <p>Hi All! Today I thought of writing about some research work that I did as part of my PhD which is an intersection between <a href="https://en.wikipedia.org/wiki/Machine_learning">machine learning</a> and <a href="https://en.wikipedia.org/wiki/Anomaly_detection">anomaly detection</a>. In a nutshell an anomaly is a novel pattern in a dataset that was never observed before or a pattern that is rarely seen. Identifying anomalies in data has a lot of important use cases. For example consider the case of an ECG reading of a heart patient. Automatically identifying anomalous patterns can greatly help doctors diagnose illnesses effectively and efficiently, there by increasing the chance of saving lives. In the recent past Machine learning and AI have been successfully used in many scenarios for anomaly detection. In this piece of work we develop a model called <strong>RAMP</strong> short of <strong>Real-Time Aggregated Matrix Profile</strong> that is able to identify anomalous patterns in a multivariate time series (i.e., a time series with many features) in an online real-time manner.</p> <p>The image above is the architecture of RAMP. RAMP is designed for applications where the data forms a time series stream, meaning there is a continues flow of data. Streaming data poses an additional challenge for machine learning based anomaly detection models. Usually in machine learning, models generalize patterns in data based on pre-collected training datasets by training on them offline (e.g., most deep learning models). Usually, this offline training process requires substantial amount of time and computational resources. However, in streaming data, the data arrives continuously and patterns are bound to continuously change meaning that models must learn temporal behavior in an online manner on the fly. So that was our challenge, we had to make sure our model is fast enough to keep up with the stream of data while ensuring it can still learn complex temporal patterns and identify anomalies at the same time. In todays’ post I will be going through a brief overview of RAMPs’ features and its key ideas along with an implementation in python. Full disclosure, this post itself might not be sufficient to completely understand all the inner working of RAMP, rather what I wanted to write about was why we designed RAMP in this way and the challenges it overcomes. If you want more in depth information about our model please refer to the <a href="https://github.com/dherath/RAMP">code</a>, <a href="http://dinalherath.com/papers/2019RAMP_extended_paper.pdf">paper</a> or <a href="https://www.researchgate.net/publication/337927011_Slides_-_RAMP_Real-Time_Anomaly_Detection_in_Scientific_Workflows">slides</a>.</p> <p>We experimented RAMP on streaming system logs collected from <a href="https://dataview.org">DATAVIEW</a>, a scientific workflow management system used for conducting large scale experiments with the aid of Amazon EC2 virtual machines (e.g., forecasting earthquakes, diagnosing illnesses). By using RAMP we showed that it is possible to identify a variety of anomalies in such systems and possible malicious activity that may have been carried out to falsify research. We selected such a domain because falsified research findings can have serious implications in many areas. For example imagine if fraudulent research was used for drug discovery for some disease, then it could have serious side effects for any patient that use those drugs. Or imagine a governmental policy decision was carried unknowingly based on some falsified research, this again could have serious negative implications on the society at large. Therefore, ensuring that research is credible and reproducible is of great importance in the research community [<a href="https://nbakay.wordpress.com/2018/10/06/peer-reviewed-scientific-research-losing-credibility-as-studies-show-they-are-rigged-or-false/">1</a>,<a href="https://www.press.umich.edu/9717920/fraud_and_misconduct_in_research">2</a>]. On another note, scientific workflows run on dedicated machines and hardware. Therefore, capturing anomalies in those systems as they occur is of paramount importance so as to not waste precious computational resources. The system logs form a multivariate time series that reflects the current execution state of any given experiment on the Amazon machines. In the github code, I have also provided an example of how RAMP works for a simple dataset collected on DATAVIEW. As shown in the image RAMP continuously monitors the stream of data and gives an indication of an anomaly to the user. As shown in the image above RAMP works as follows:</p> <ol> <li>Identifies potential anomalies in the streaming data using the <strong>Anomaly Detection</strong> module</li> <li><code class="highlighter-rouge">If</code> an anomaly flag is raised: undergoes one training cycle using <strong>Adaptive Training</strong> module using the <strong>Uncertainty Function</strong> (Note: no human feedback is given)</li> <li><em>Optionally</em> can undergo an additional training cycle if human feedback is given using <strong>Human-In-The-Loop Training</strong> (to rectify any errors made by RAMP)</li> </ol> <h4 id="1-anomaly-detection">1. Anomaly Detection</h4> <p>We built the <strong>Anomaly Detection</strong> module by improving on an existing time series analysis model called the <a href="https://www.cs.ucr.edu/~eamonn/MatrixProfile.html">Matrix Profile</a> (<strong>super stoked and humbled that our work is also featured in the original MP page :)</strong> ). Basically, the idea behind Matrix Profile is quite intuitive. Given a time series, the model breaks it into small subsequences of some predefined small length before operating on them. For example, assume a univariate time series with 50 data points <script type="math/tex">T= \{t_1, t_2, ..., t_{50} \}</script> and the subsequence length <script type="math/tex">m = 3</script>, then the first subsequence will be <script type="math/tex">\{t_1,t_2,t_3\}</script> and the final subsequence being <script type="math/tex">\{t_{48}, t_{49}, t_{50} \}</script>. Then the set of all subsequences are <script type="math/tex">\{ \{t_1, t_2, t_3 \}, \{t_2, t_3, t_4 \}, ..., \{t_{48}, t_{49}, t_{50} \} \}</script>. The Matrix Profile (MP) works as follows:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For each subsequence:
  (1) Compute distance between current subsequence and the entire subsequence set
  (2) Find the minimum from the above computed distance excluding distance to itself
  (3) Append the identified min-distance as the MP value for current subsequence
</code></pre></div></div> <p>For some subsequence, if the MP value is zero or a very small value then it means that subsequence is a common pattern that occurs within the times series. If the MP value is very large that means the pattern in question is an outlier or an anomaly. In our anomaly detection algorithm, we extend and modify the vanilla Matrix Profile approach to work with a streaming multivariate data source. I won’t go into our exact modifications here, instead I will refer you to the <a href="https://www.researchgate.net/publication/337927011_Slides_-_RAMP_Real-Time_Anomaly_Detection_in_Scientific_Workflows">slides</a> or the <a href="http://dinalherath.com/papers/2019RAMP_extended_paper.pdf">paper</a> for more information. Our anomaly detection algorithm, takes each oncoming subsequence as its input and computes a weighted aggregated anomaly score <script type="math/tex">\beta</script>. If this anomaly score is greater than some user defined threshold (<script type="math/tex">\beta > \theta</script>) then it returns <strong>True</strong> for anomaly. Additionally, given a multivariate time series, our algorithm also returns the features that contributed towards an identified anomaly instance. Thereby some user or administrator will be able to diagnose the root cause of an anomaly.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">anomaly_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">proc_id</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="s">""" identifies if an anomaly is present in sub-sequence T """</span>
        <span class="s">""" ----------------------- """</span>
        <span class="s">""" @param t : the time step [0,...,M-1] within the window M """</span>
        <span class="s">""" @param T : a multi-dimensional subsequence [d,m] """</span>
        <span class="s">""" @param proc_id : the id of the process if experiment is interleaved, 0 is default """</span>
        <span class="s">""" ----------------------- """</span>
        <span class="s">""" @return [anomaly_detected,beta,C_t] """</span>

        <span class="n">beta</span> <span class="o">=</span> <span class="mi">0</span> <span class="s">""" anomaly score """</span>
        <span class="n">key</span> <span class="o">=</span> <span class="mi">0</span> <span class="s">""" index of the weight dictionary """</span>
        <span class="n">C_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span> <span class="s">""" contribution to beta from all features/dimensions """</span>
        <span class="n">D_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span> <span class="s">""" an empty list to store min(Distance-value) for each d """</span>
        <span class="s">""" computing the relative distance for each dimension/feature """</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">):</span>
            <span class="n">min_rd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="s">""" initially has infinite relative distance """</span>
            <span class="n">min_k</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="s">""" a temp variable for computing the index of the weight """</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">):</span>
                <span class="n">abs_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">T_</span><span class="p">[</span><span class="n">proc_id</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">])))</span>
                <span class="n">compared_with</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_</span><span class="p">[</span><span class="n">proc_id</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">]))</span>
                <span class="n">relative_distance</span> <span class="o">=</span> <span class="n">abs_distance</span> <span class="o">/</span> <span class="n">compared_with</span>
                <span class="k">if</span> <span class="n">relative_distance</span> <span class="o">&lt;</span>  <span class="n">min_rd</span><span class="p">:</span>
                    <span class="n">min_rd</span> <span class="o">=</span> <span class="n">relative_distance</span>
                    <span class="n">min_k</span> <span class="o">=</span> <span class="n">k</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">proc_id</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_k</span>
            <span class="n">key</span> <span class="o">+=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span><span class="o">**</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">min_k</span>
            <span class="n">beta</span> <span class="o">+=</span> <span class="n">min_rd</span>
            <span class="n">D_min</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_rd</span>
        <span class="s">""" -------------------- """</span>
        <span class="n">C_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">D_min</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span> <span class="k">if</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">))</span> <span class="s">""" computing the contribution to the anomaly """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">proc_id</span><span class="p">,</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="k">if</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1e-10</span><span class="p">)</span> <span class="s">""" updating the ratio between (un weighted beta/theta) """</span>
        <span class="s">""" computing the weighted score """</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">proc_id</span><span class="p">]:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">proc_id</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="s">""" get anomaly flag """</span>
        <span class="k">if</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">C_t</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">False</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">C_t</span><span class="p">]</span>
</code></pre></div></div> <h4 id="2-adaptive-training">2. Adaptive Training</h4> <p>Whenever a possible anomaly is identified, RAMP undergoes one training cycle. This training cycle is needed to reduce the <strong>False Positives</strong> identified. In our training algorithm the weights used to compute the anomaly score are modified.</p> <blockquote> <p>The biggest question of anomaly detection is, how can a model decide if an anomaly flag (i.e. True for anomaly) is actually some malicious activity or that it signifies something wrong instead of it have being a false alarm, without any human intervention?.</p> </blockquote> <p>To answer this question we gave RAMP the ability to <strong>guess</strong>. We defined a novel feature called the <strong><code class="highlighter-rouge">uncertainty function</code></strong> that gives a probabilistic value <script type="math/tex">p</script> (i.e., between 0 and 1) that indicates whether RAMP should consider the anomaly instance as a <strong>True Positive</strong> or a <strong>False Alarm</strong>. The training algorithm biases the degree to which the weights are modified depending on the value of <script type="math/tex">p</script>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">uncertainty_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">proc_time</span><span class="p">,</span><span class="n">proc_id</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="s">""" gives a probabilistic value for the uncertainty of whether an anomaly flagged is TP or FP """</span>
    <span class="s">""" ----------------------- """</span>
    <span class="s">""" @param proc_time : the time with respect to the individual process [0,...,inf] """</span>
    <span class="s">""" @param proc_id : the ID for the interleaved process, default = 0 """</span>
    <span class="s">""" ----------------------- """</span>
    <span class="s">""" @return probabilistic value [0,1], if ~1 then most likely TP """</span>

    <span class="k">if</span> <span class="n">proc_time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="nb">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">[</span><span class="n">proc_id</span><span class="p">]</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">-</span> <span class="n">proc_time</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">adaptive_training</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">proc_id</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="s">"""conducts one training cycle, does not return because W,H are defined in class"""</span>
    <span class="s">""" ----------------------- """</span>
    <span class="s">""" @param t: time step [0,...,M-1] within the range M """</span>
    <span class="s">""" @param p: the result from the uncertainty function """</span>
    <span class="s">""" @param proc_id : the process id, default = 0 for only one process """</span>
    
    <span class="n">keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="s">""" the indices of the weights to train """</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="s">""" compute the index for the weights """</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">):</span>
            <span class="n">keys</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span><span class="o">**</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">proc_id</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
        <span class="s">""" add weight into W, if it does not exist in W """</span>
        <span class="k">if</span> <span class="n">keys</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">proc_id</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">proc_id</span><span class="p">][</span><span class="n">keys</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="s">""" weight updating step """</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="p">:</span>
            <span class="n">beta_unweighted</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">proc_id</span><span class="p">,</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">proc_id</span><span class="p">][</span><span class="n">keys</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">proc_id</span><span class="p">][</span><span class="n">keys</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>  <span class="o">*=</span> <span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">proc_id</span><span class="p">,</span><span class="n">t</span><span class="p">])</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">proc_id</span><span class="p">,</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">proc_id</span><span class="p">][</span><span class="n">keys</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">*</span> <span class="n">beta_unweighted</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">proc_id</span><span class="p">][</span><span class="n">keys</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>  <span class="o">*=</span> <span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">proc_id</span><span class="p">,</span><span class="n">t</span><span class="p">])</span> <span class="p">)</span>
    <span class="k">return</span>
</code></pre></div></div> <h4 id="3-human-in-the-loop-training">3. Human-in-the-loop Training</h4> <p>Even though RAMP can guess and trains its own parameters there might be instances where the guess itself is wrong. In those instances RAMP needs some external input to rectify any mistake. From a models point of view, the most sure proof way of obtaining external input is from some human operator. Therefore we also develop an optional <strong>Human-In-The-Loop</strong> training module. This component has two functionalities - (1) to rectify any unwanted training resulting because RAMP may have mistakenly modified weights of a true positive anomaly instance thinking its a false alarm and (2) updating the parameters of the uncertainty function based on the number of false alarms reported by RAMP in the recent past. However, it should be noted that this is an optional component and its entirely possible to run RAMP without it.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">human_in_the_loop_training</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">proc_time</span><span class="p">,</span><span class="n">num_fp</span><span class="p">,</span><span class="n">U_TP</span><span class="p">,</span><span class="n">proc_id</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="s">""" optional periodic training, if user feedback is given, does not return """</span>
    <span class="s">""" because K,W are defined in class """</span>
    <span class="s">""" ----------------------- """</span>
    <span class="s">""" @param proc_time : the time index for the current process [0,..,inf] """</span>
    <span class="s">""" @param num_fp : the total number of false positives marked """</span>
    <span class="s">""" @param U_TP : the indices for the True Positives [0,..,M-1] """</span>
    <span class="s">""" @param proc_id : the process id, default = 0 """</span>

    <span class="s">""" update step for the uncertainty function parameter """</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">[</span><span class="n">proc_id</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">proc_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">[</span><span class="n">proc_id</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">num_fp</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
    <span class="s">""" weight update step for True Positives """</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">U_TP</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="mi">0</span> <span class="s">""" the index of the weight """</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">+=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span><span class="o">**</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">proc_id</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">proc_id</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">proc_id</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">proc_id</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">proc_id</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span>
</code></pre></div></div> <p>There you have it, my first ever anomaly detection model <strong>RAMP</strong>. If you find it interesting please do read the <a href="http://dinalherath.com/papers/2019RAMP_extended_paper.pdf">paper</a>, <a href="https://www.researchgate.net/publication/337927011_Slides_-_RAMP_Real-Time_Anomaly_Detection_in_Scientific_Workflows">slides</a> and play with the <a href="https://github.com/dherath/RAMP">code</a>.</p> <h5 id="so-until-next-time">So until next time,</h5> <h5 id="cheers">Cheers!</h5> <p><strong>Next: <a href="http://dinalherath.com/2020/autoencoder/">Anomaly detection with Deep AutoEncoders</a></strong> <br /> <strong>Prev: <a href="http://dinalherath.com/2019/rnn/">Implementing Deep Recurrent Neural Networks (RNN)</a></strong></p> <aside class="share"> <p>If you liked this article and think others should read it, please <a href="http://twitter.com/share?text=RAMP: Real-Time Aggregated Matrix Profile&amp;url=http://dinalherath.com/2020/ramp/&amp;via=" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">share it on Twitter <i class="fa fa-twitter" aria-hidden="true" style="color:#00aced"></i></a> or <a href='https://www.facebook.com/sharer/sharer.php?u='+url; onclick="window.open(this.href, 'sharer', 'toolbar=0,status=0,width=550,height=235');return false;">Facebook <i class="fa fa-facebook-square" aria-hidden="true" style="color:#3b5998"></i></a>.</p> </aside> </div> </article> <!-- --> <footer class="site-footer"> <!--<link rel="stylesheet" href="/assets/icons/academicons-1.8.0/css/academicons.css"/>--> <div class="container"> <small class="block"><!--&lt;/&gt; <a href="http://github.com/heiswayi/thinkspace" title="a minimalist Jekyll theme for technical writing">Thinkspace theme</a> by <a href="http://heiswayi.github.io">Heiswayi Nrird</a>. |--><i class="fa fa-copyright"></i> 2017-2021 Jerome Dinal Herath</small> <a href="mailto:dinal.bing@gmail.com"><i class="fa fa-envelope" style="font-size:21px;color:#F15B3D;"></i></a> <a href="https://www.facebook.com/dinalHerath" target="_blank"><i class="fa fa-facebook-square" style="font-size:22px;color:#F15B3D"></i></a> <a href="https://github.com/dherath" target="blank"><i class="fa fa-github-square" style="font-size:22px;color:#F15B3D"></i></a> <a href="https://www.linkedin.com/in/jerome-dinal-herath-bba3b0148/" target="blank"><i class="fa fa-linkedin-square" style="font-size:22px;color:#F15B3D"></i></a> <a href="/feed.xml" target="_blank"><i class="fa fa-rss-square" style="font-size:22px;color:#F15B3D"></i></a> <a href="https://www.researchgate.net/profile/Jerome_Dinal_Herath" target="blank"> <i style="font-size:20px;color:#F15B3D;font-weight:bold;"> RG </i></a> </div> </footer> </main> </body> </html>
