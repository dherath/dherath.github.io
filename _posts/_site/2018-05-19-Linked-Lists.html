<p><img src="https://github.com/dherath/WebsiteMaterial/blob/master/2018/Post_9_LinkedList/linked_list_org.jpeg?raw=true" alt="cycled-linked-list" height="200px" /></p>

<p>Hello Everyone!! Hope everyone is doing ok, the previous semester was pretty hectic with research work and courses so didn’t really have time to write anything up. But now I’m back <i class="fa fa-smile-o" style="font-size:20px;"></i> and in todays post I thought of writing something interesting I learned in a course and something that apparently ends up being a common interview question for coding/developing positions–that is to <em><code class="highlighter-rouge">"identify cycles in a linked list"</code></em>. If you are from a CS background, you’d probably know that job interviews usually consist of a couple of problems which test a candidates knowledge on algorithms &amp; data structures. If you just stumbled across my post and if you had no idea of this, well now you know.</p>

<p>Anyways, without digressing anymore back to my topic–linked lists are a basic data structure like arrays which are used quite a lot. Now if you have no idea about linked lists and you want to learn about them then this is not the post for that. There are lots of youtube tutorials and posts online which would probably give you a fair understanding on how this data structure works. Click on these links to learn more about linked lists - <a href="https://www.youtube.com/watch?v=NobHlGUjV3g">[youtube]</a>, <a href="https://www.geeksforgeeks.org/linked-list-set-1-introduction/">[weblink]</a></p>

<h3 id="the-problem--a-cyclic-linked-list">The problem : a cyclic linked list</h3>

<p>Now to our problem at hand. I’m assuming you know how a link list works, so basically as depicted above each link would have some storage capability to store data and a pointer to the next link which is the arrow. So if you look at the image above, the linked list starts from the red link at the left end and moves to the right. If you follow through the connectivity of this linked list starting form the red links shown in the image above you would notice that the traversal itself would never stop. Because the green pointer (<em>the arrow</em>) of the list would point again to the blue link which in-turn points back to the green links.</p>

<p>This would be a nightmare in real code because the code will run in an infinite loop. And the worst part is its caused because of the connectivity of the underlining data structure and not an issue with the core programing logic, so figuring it out could be tricky also.  But as it turns out there is a simple algorithm that can check if there are any cycles in a linked list.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// definition for a Node in a link list
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
	<span class="n">Data</span> <span class="n">value</span><span class="p">;</span> <span class="c1">// the data structure
</span>
	<span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// pointer to next node
</span>
<span class="p">}</span><span class="n">Node</span><span class="p">;</span>

<span class="c1">// definition of the linked list
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Linkedlist</span><span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span><span class="n">Linkedlist</span><span class="p">;</span>
</code></pre></div></div>

<p>Lets consider the above basic <strong>C</strong> declarations for a Node (link) and the linked list. I’ll be explaining the working algorithm using a <strong>C</strong> skeleton code so I’m again assuming you have some working knowledge of <strong>C</strong> and pointers. If you don’t know much about this, think of <code class="highlighter-rouge">Node</code> and <code class="highlighter-rouge">Linkedlist</code> as two classes where the linked list has a reference to its <em>head</em> (i.e. its starting location) and each <em>Node</em> has a reference to the data and the Node connected to it.</p>

<h3 id="cycle-detection-algorithm">Cycle detection algorithm</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">detectCycle</span><span class="p">(</span><span class="n">Linkedlist</span> <span class="o">*</span> <span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Node</span> <span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">head</span> <span class="p">,</span> <span class="o">*</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">Node</span> <span class="o">*</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">f1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">f1</span> <span class="o">&amp;&amp;</span> <span class="n">f2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">f1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">f1</span> <span class="o">||</span> <span class="n">s</span> <span class="o">==</span> <span class="n">f2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The algorithm itself isn’t pretty long right? But how does this work? I’ll explain that next. First of all the algorithm checks if <code class="highlighter-rouge">l-&gt;head == NULL</code> which indicates if the linked list is empty or not, if it’s empty then it returns <strong>0</strong> meaning there is no cycle. The algorithm works on the three pointers <strong><code class="highlighter-rouge">s, f1 and f2</code></strong> which means <em>start, fast1 and fast2</em>. These pointers reference some <strong>node</strong> in the link list. Initially both the pointers of <strong><code class="highlighter-rouge">s and f1</code></strong> point to the head of the linked list while <strong><code class="highlighter-rouge">f2</code></strong> refers to the node right after the head. The idea is very simple, at every instance of the while loop the pointers <strong><code class="highlighter-rouge">f1, f2</code></strong> are moved forward in the list by two positions while the pointer <strong><code class="highlighter-rouge">s</code></strong> is moved by one position. (<em>Now you might notice the reason ‘f1,f2’ are named fast is because these pointers traverse the list faster than ‘s’</em>) Given there is a cycle then at some point <code class="highlighter-rouge">f1 == s OR f2 == s</code> then the algorithm returns <strong>1</strong> else if any of the pointers finish traversing the list it returns <strong>0</strong>.</p>

<p>Lets work this out for the linked list drawn above, I will name each node with a number from 1-8 where the first red node to the left is 1 and the final green node 8. In the table below I’ll show the position of the pointers at each step of the while loop.</p>

<p><img src="https://github.com/dherath/WebsiteMaterial/blob/master/2018/Post_9_LinkedList/linked_list_numbered.jpeg?raw=true" alt="cycled-linked-list" height="150px" /></p>

<table>
  <tbody>
    <tr>
      <td><strong>timestep</strong></td>
      <td><strong>pointer s</strong></td>
      <td><strong>pointer f1</strong></td>
      <td><strong>pointer f2</strong></td>
    </tr>
    <tr>
      <td><strong>Initially</strong></td>
      <td>1 (head)</td>
      <td>1 (head)</td>
      <td>2</td>
    </tr>
    <tr>
      <td><strong>step 1</strong></td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <td><strong>step 2</strong></td>
      <td>3</td>
      <td>5</td>
      <td>6</td>
    </tr>
    <tr>
      <td><strong>step 3</strong></td>
      <td>4</td>
      <td>7</td>
      <td>8</td>
    </tr>
    <tr>
      <td><strong>step 4</strong></td>
      <td>5</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <td><strong>step 5</strong></td>
      <td><strong><code class="highlighter-rouge">6</code></strong></td>
      <td>5</td>
      <td><strong><code class="highlighter-rouge">6</code></strong></td>
    </tr>
  </tbody>
</table>

<p>At step 5 <strong><code class="highlighter-rouge">f2 == s</code></strong> which means there is a cycle. So there you go, a simple algorithm to identify cycles in linked lists.</p>

<h5 id="so-until-next-time">So until next time,</h5>
<h5 id="cheers">Cheers!</h5>

<p><strong>Next: <a href="/2018/git-support/">Adding git support to Terminal</a></strong> <br />
<strong>Prev: <a href="/2018/Markov-Chains/">Markov Chains 101</a></strong></p>
