<p>Hello Everyone !!! Hope you all had an amazing week, If you’re in college the new semester probably just started and I hope you’re first few weeks were awesome, I just started grad school and my week was pretty good :). Now moving on with my post, this will be a continuation from my previous post <a href="https://dherath.github.io/2017/hard-disks-1/" target="blank"><strong>‘Simulation of Hard Disks - Part 1’</strong></a> where I tackled this very same problem using <strong><code class="highlighter-rouge">Newtonian deterministic mechanics</code></strong>. Ok, so if this is the first time you’re hearing the word <em><strong>Hard disks</strong></em> I do suggest reading my first post where I explain the terms and the rationale behind simulations of this sort.</p>

<p><img src="http://teachbesideme.com/wp-content/uploads/2015/02/solid-liquid-gas-1024x346.jpg" alt="intro-image" /></p>

<p>In my last post I ended on a note that suggested the previous simulation technique has some limitations. So today I’ll start from there, the entire point of simulating hard disks is to predict the behavior of particle systems that we might find in the real world. However such systems have more than 4 particles, and in the previous technique we had to solve the <strong>equations of motion for the entire system for every step</strong>. While this was possible for 4 particles it would be ridiculously time consuming for a system with 1,000,000s of particles. <code class="highlighter-rouge">That in itself is the flaw with this method</code>. This exponential increase in computational complexity drove many scientists to find better ways of simulating hard disk problems.</p>

<p><strong><code class="highlighter-rouge">So the questions is, what is this better way to simulate hard disks?</code></strong> that’s what todays post is all about.</p>

<h3 id="simulating-hard-disks-using-direct-sampling">Simulating hard disks using direct sampling</h3>

<p>As per the title the simulations I will be presenting today are based on a technique called <strong>‘direct sampling’</strong> which is an interesting concept which stems from the idea of <code class="highlighter-rouge">randomness</code>. So what is this <em><strong>direct sampling?</strong></em></p>

<blockquote>
  <p>In a nutshell, direct sampling is sort of like randomly picking an apple from a basket of apples and hoping its ripe.  However, note that the ripeness of apples will vary according to some distribution(<em>Uniform, Poisson,…</em>). The interesting thing here being there is always some <strong>probability</strong> that an apple we picked is ripe, so sometimes we might get a good one sometimes we might not luck out.</p>
</blockquote>

<p>This idea of using randomness is a corner stone of modern day statistical mechanics. The gif below shows the output from the simulation technique I’ll be discussing today.</p>

<p><img src="https://raw.githubusercontent.com/dherath/WebsiteMaterial/master/2017/post_5_hard_disks_2/directDisks_animation.gif" alt="hard-disks-gif" width="450px" /></p>

<p>If you look closely at the gif above, you would notice a clear difference with respect to the earlier technique.  In Newtonian mechanics the simulation revolves with time which means that some state <em>i</em> is directly dependent on its previous <em>i-1</em> state. So in a <code class="highlighter-rouge">gif</code> it looks as if the particles are moving and colliding in real time. However, in this case the the <code class="highlighter-rouge">gif</code> just shows different <em>configurations(or samples)</em> of some state that could occur at any time. To explain it in a different way, all the samples you see in the <em>gif</em> above are configurations that the disks could take at some point in time(<em>we don’t know when)</em> that are valid.</p>

<blockquote>
  <p><strong><code class="highlighter-rouge">So what does it mean to have a valid configuration?</code></strong>
 A valid configuration, is some placement of the disks within the boundary of the box that doesn’t overlap with each other.</p>
</blockquote>

<p>So basically, the <em>gif</em> above just shows some set of legal configurations that the disks could take, it doesn’t necessarily show how the system evolves with time. This is both good and bad.  The surprising thing about random sampling is that in terms of simulating hard disks, its possible to replicate the same results we observed from running simulations using Newtonian Mechanics. Before I go into detail about that, first I’ll go through the code for this technique.</p>

<h4 id="the-code">The Code</h4>

<p>I’ll be demonstrating this technique using Matlab, and unlike the previous method this does not require the use of functions. Since the simulation contains only 4 disks, there can be only 4 possibilities for wall-disk collisions and 6 possibilities for disk-disk collisions as per the table below.</p>

<table>
  <thead>
    <tr>
      <th>Disk type A</th>
      <th style="text-align: center">Disk Type B</th>
      <th style="text-align: right">Number of collisions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td style="text-align: center">2, 3, 4</td>
      <td style="text-align: right">3</td>
    </tr>
    <tr>
      <td>2</td>
      <td style="text-align: center">3, 4</td>
      <td style="text-align: right">2</td>
    </tr>
    <tr>
      <td>3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: right">1</td>
    </tr>
    <tr>
      <td><strong>Total No.of collisions</strong></td>
      <td style="text-align: center"> </td>
      <td style="text-align: right"><strong><code class="highlighter-rouge">6</code></strong></td>
    </tr>
  </tbody>
</table>

<p>Within the code snippet below, the first few lines of the code determine the initial conditions such as the radius, number of disks, their respective locations and the set of possible collisions of all the disks <em>(which is 6 disk-disk collision pairs &amp; 4 wall-disk collision pairs)</em>. Afterwards for a given number of iterations(<em>defined by n</em>) a loop is run for each sample state where each turn 4 random locations for the disks are computed such that the <strong>minimum distance between any two disks is greater than the diameter of a disk</strong>. <code class="highlighter-rouge">This condition ensures that no two disks overlap with each other.</code></p>

<p>The step for the simulation is not increased until this condition is met, say for an example if the 100th iteration computes an invalid configuration where an overlap is only present between the 1st &amp; 3rd disks where as the 2nd &amp; 4th disks are valid; even then the <strong><code class="highlighter-rouge">entire set is rejected resulting in the sample space being completely erased</code></strong>. This form of rejections are called the <strong><em>tabula rasa rejections</em></strong>. These continues rejections occur until a valid set of configurations are obtained, only then would the iteration <code class="highlighter-rouge">count</code> be increased from 100 to 101.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clc</span><span class="p">;</span>
<span class="nb">clear</span><span class="p">;</span>
<span class="n">N</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
<span class="n">radius</span><span class="o">=</span><span class="mf">0.15</span><span class="p">;</span>
<span class="n">diamtr</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">;</span>
<span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="n">radius</span><span class="p">;</span>
<span class="n">a</span><span class="o">=</span><span class="n">radius</span><span class="p">;</span>
<span class="n">dx</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">dy</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">d</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
<span class="n">wall</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">4</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">];</span>
<span class="n">pair</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">];</span>
<span class="n">n</span><span class="o">=</span><span class="mi">1000000</span><span class="p">;</span><span class="c1">%number of samples</span>
<span class="nb">count</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">distanceVals</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span>

<span class="k">while</span> <span class="nb">count</span> <span class="o">&lt;</span> <span class="n">n</span>
	<span class="c1">%------positions for disks -----------------------</span>
        <span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span>
            <span class="n">dx</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">.*</span><span class="nb">rand</span><span class="o">+</span><span class="n">a</span><span class="p">;</span>
            <span class="n">dy</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">.*</span><span class="nb">rand</span><span class="o">+</span><span class="n">a</span><span class="p">;</span>
            <span class="n">d</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">count</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">dx</span><span class="p">(</span><span class="nb">i</span><span class="p">);</span>
            <span class="n">d</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">count</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">dy</span><span class="p">(</span><span class="nb">i</span><span class="p">);</span>
        <span class="k">end</span><span class="p">;</span>

        <span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">6</span>
            <span class="n">dxa</span><span class="o">=</span><span class="n">d</span><span class="p">(</span><span class="n">pair</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="nb">count</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">dya</span><span class="o">=</span><span class="n">d</span><span class="p">(</span><span class="n">pair</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">2</span><span class="p">,</span><span class="nb">count</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">dxb</span><span class="o">=</span><span class="n">d</span><span class="p">(</span><span class="n">pair</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="nb">count</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">dyb</span><span class="o">=</span><span class="n">d</span><span class="p">(</span><span class="n">pair</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">,</span><span class="nb">count</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">distanceVals</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">=</span> <span class="nb">sqrt</span><span class="p">((</span><span class="n">dxa</span><span class="o">-</span><span class="n">dxb</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">dya</span><span class="o">-</span><span class="n">dyb</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">);</span>  
        <span class="k">end</span><span class="p">;</span>        	

        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">distanceVals</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">diamtr</span>
            <span class="nb">count</span><span class="o">=</span><span class="nb">count</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    	<span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<h4 id="the-results">The Results</h4>

<p>The biggest question you’d probably have after reading thus far about this technique would be <code class="highlighter-rouge">How could this even work?</code>. Which is a completely reasonable question, because in Newtonian mechanics the actual equations of motion were computed. Therefore, within the classical boundary the simulation replicates particle motion.</p>

<p>However, here in simple terms all we do is randomly place the particles in a given space for some number of rounds and then bin their locations and now supposedly <strong>I say</strong> it shows the same behavior as the previous case. The graphs below show a comparison between the histograms for the disk locations for simulations run using Newtonian mechanics and direct sampling for disks 1 &amp; 2(<em>disks 3 &amp; 4 show the same behavior</em>).</p>

<p><strong>01) histogram of X &amp; Y coordinates for disk 1 (MD-Molecular Dynamics, Direct- direct sampling)</strong>
<img src="https://raw.githubusercontent.com/dherath/WebsiteMaterial/master/2017/post_5_hard_disks_2/comparison_disk1.jpg" alt="disk-1-coordinate-sample" /></p>

<p><strong>02) histogram of X &amp; Y coordinates for disk 2 (MD-Molecular Dynamics, Direct- direct sampling)</strong>
<img src="https://raw.githubusercontent.com/dherath/WebsiteMaterial/master/2017/post_5_hard_disks_2/comparison_disk2.jpg" alt="disk-2-coordinate-sample" /></p>

<p>The position distributions show the same behavior where the disks seem to be more attracted towards the edges. As I explained in my previous post the reason behind this phenomena is primarily due to an entropic interaction where at each instance the disks individually try to make more room for the others. The interesting thing here is that even without resorting to complex computations, behavior of complex systems could be replicated using this idea of <code class="highlighter-rouge">randomness</code>. However this technique does have its own limitations.</p>

<p>Since the simulation doesn’t evolve with time this technique alone is not sufficient to obtain any idea about how the velocities of the disks vary unlike in the previous case where we saw a Boltzmann distribution for the velocities.  Even amidst this, the significant improvement with regards to reducing the computational complexity is very attractive specifically when considering systems with millions of particles. So with that being said I’ll end my post here hoping you all have a newfound appreciation for the power of <code class="highlighter-rouge">randomness</code>. (<em>At least in the realm of scientific computing</em>)</p>

<h5 id="so-until-next-time">So until next time,</h5>
<h5 id="cheers">Cheers!</h5>

<p><strong>Next: <a href="http://dinalherath.com/2017/Computational-Physics-to-Computer-Science/">From Computational Physics to Computer Science</a></strong>                                                     <br />
<strong>Prev: <a href="http://dinalherath.com/2017/hard-disks-1/">Simulation of Hard Disks : Part 1</a></strong></p>
